# =================================================================================================
# üå¨Ô∏è VENTILATION BAIE V2 - Configuration ESPHome (Dual Zone)
# =================================================================================================
# Ce fichier configure un syst√®me de ventilation intelligent √† 2 zones ind√©pendantes :
# - Ligne 1 (Zone Haute) : Ventilateurs + Capteur DHT22
# - Ligne 2 (Zone Basse) : Ventilateurs + Capteur DHT22
#
# Fonctionnalit√©s : Mode Auto (r√©gulation temp√©rature), Mode Boost, Fail-Safe, Interlock surchauffe
# =================================================================================================

substitutions:
  name: "esp-fan"
  friendly_name: "Ventilation Baie"
  # Variables pour .base.yaml
  board: esp32-s3-devkitc-1
  type: esp-idf
  loglevel: INFO
  static_ip: 192.168.1.100  # ‚ö†Ô∏è Remplacez par l'IP souhait√©e pour ce module

packages:
  base: !include .base.yaml

# =================================================================================================
# API HOME ASSISTANT
# =================================================================================================
# ‚ö†Ô∏è IMPORTANT : Lors de la cr√©ation du "New Device", ESPHome g√©n√®re une cl√©. 
# R√©cup√©rez-la et remplacez la valeur ci-dessous. 
# (Ou g√©n√©rez-en une avec la commande : esphome encryption-key)
api:
  encryption:
    key: "VOTRE_CL√â_API_FOURNIE_PAR_ESPHOME=="

# =================================================================================================
# MAT√âRIEL : SORTIES PWM (Contr√¥le de vitesse des ventilateurs)
# =================================================================================================
output:
  # PWM Ligne 1 (Zone Haute) - GPIO6
  - platform: ledc
    pin: GPIO6
    id: pwm_line_1
    frequency: 25000 Hz
    min_power: 0.0
    max_power: 1.0

  # PWM Ligne 2 (Zone Basse) - GPIO35
  - platform: ledc
    pin: GPIO35
    id: pwm_line_2
    frequency: 25000 Hz
    min_power: 0.0
    max_power: 1.0

# =================================================================================================
# CAPTEURS : TACHYM√àTRES (RPM) ET DHT22 (Temp√©rature/Humidit√©)
# =================================================================================================
sensor:
  # --- LIGNE 1 (Zone Haute) ---
  
  # Tachym√®tre Ligne 1 (GPIO4)
  - platform: pulse_counter
    pin: 
      number: GPIO4
      mode: {input: true, pullup: true}
    name: "Vitesse Ligne 1"
    unit_of_measurement: 'RPM'
    id: speed_line_1
    filters: [{lambda: return x / 2.0;}]  # Division par 2 (format signal tachym√®tre ventilateur)
    update_interval: 3s
  
  # Capteur DHT22 Ligne 1 (GPIO7) - Temp√©rature
  - platform: dht
    pin: GPIO7
    model: DHT22
    temperature:
      name: "Temp√©rature Ligne 1"
      id: temp_1
      on_value:
        then: [script.execute: update_ventilation]  # D√©clenche le recalcul √† chaque nouvelle mesure
    update_interval: 5s

  # Calcul de la puissance actuelle (%) Ligne 1
  - platform: template
    name: "Puissance Ventilateur L1"
    unit_of_measurement: "%"
    icon: "mdi:percent"
    accuracy_decimals: 0
    lambda: |-
      return id(fan_1).state ? id(fan_1).speed : 0;
    update_interval: 5s

  # --- LIGNE 2 (Zone Basse) ---
  
  # Tachym√®tre Ligne 2 (GPIO36)
  - platform: pulse_counter
    pin: 
      number: GPIO36
      mode: {input: true, pullup: true}
    name: "Vitesse Ligne 2"
    unit_of_measurement: 'RPM'
    id: speed_line_2
    filters: [{lambda: return x / 2.0;}]
    update_interval: 3s

  # Capteur DHT22 Ligne 2 (GPIO37) - Temp√©rature
  - platform: dht
    pin: GPIO37
    model: DHT22
    temperature:
      name: "Temp√©rature Ligne 2"
      id: temp_2
      on_value:
        then: [script.execute: update_ventilation]
    update_interval: 5s

  # Calcul de la puissance actuelle (%) Ligne 2
  - platform: template
    name: "Puissance Ventilateur L2"
    unit_of_measurement: "%"
    icon: "mdi:percent"
    accuracy_decimals: 0
    lambda: |-
      return id(fan_2).state ? id(fan_2).speed : 0;
    update_interval: 5s

# =================================================================================================
# VENTILATEURS (Entit√©s Fan pour Home Assistant)
# =================================================================================================
fan:
  # Fan Ligne 1
  - platform: speed
    id: fan_1
    output: pwm_line_1
    name: "Ventilateurs Ligne 1"
    speed_count: 100  # R√©solution : 100 niveaux de vitesse (1-100%)

  # Fan Ligne 2
  - platform: speed
    id: fan_2
    output: pwm_line_2
    name: "Ventilateurs Ligne 2"
    speed_count: 100

# =================================================================================================
# R√âGLAGES UTILISATEUR (Numbers - Ajustables depuis Home Assistant)
# =================================================================================================
number:
  # Consigne temp√©rature MIN (0% de vitesse)
  - platform: template
    id: consigne_min
    name: "Consigne Temp Min"
    icon: "mdi:thermometer-low"
    optimistic: true
    min_value: 20
    max_value: 30
    step: 1
    initial_value: 24  # ‚ö†Ô∏è Valeur par d√©faut personnalisable
    restore_value: true
    unit_of_measurement: "¬∞C"
    on_value:
      then: [script.execute: update_ventilation]

  # Consigne temp√©rature MAX (100% de vitesse)
  - platform: template
    id: consigne_max
    name: "Consigne Temp Max"
    icon: "mdi:thermometer-high"
    optimistic: true
    min_value: 25
    max_value: 40
    step: 1
    initial_value: 35  # ‚ö†Ô∏è Valeur par d√©faut personnalisable
    restore_value: true
    unit_of_measurement: "¬∞C"
    on_value:
      then: [script.execute: update_ventilation]

  # Dur√©e du mode Boost (en minutes)
  - platform: template
    id: boost_duration
    name: "Dur√©e Boost"
    icon: "mdi:timer"
    optimistic: true
    min_value: 1
    max_value: 60
    step: 1
    initial_value: 10  # ‚ö†Ô∏è Valeur par d√©faut: 10 minutes
    restore_value: true
    unit_of_measurement: "min"

# =================================================================================================
# ALERTES S√âCURIT√â (Binary Sensors)
# =================================================================================================
binary_sensor:
  # Alerte si capteur DHT22 de la Ligne 1 ne r√©pond plus
  - platform: template
    name: "Alerte Capteur L1"
    id: alert_l1
    device_class: problem
    icon: "mdi:alert-circle"
  
  # Alerte si capteur DHT22 de la Ligne 2 ne r√©pond plus
  - platform: template
    name: "Alerte Capteur L2"
    id: alert_l2
    device_class: problem
    icon: "mdi:alert-circle"

  # Alerte Interlock : temp√©rature critique d√©pass√©e (Max + 5¬∞C)
  - platform: template
    name: "Alerte Surchauffe (Interlock)"
    id: alert_interlock
    device_class: heat
    icon: "mdi:fire-alert"

# =================================================================================================
# SWITCHES (Modes de fonctionnement)
# =================================================================================================
switch:
  # --- MODE BOOST GLOBAL ---
  # Force 100% de vitesse sur toutes les lignes pendant une dur√©e d√©finie
  - platform: template
    name: "Mode Boost"
    id: boost_mode
    optimistic: true
    icon: "mdi:rocket-launch"
    turn_on_action:
      - logger.log: "üöÄ BOOST ACTIF (Global)"
      - script.execute: update_ventilation # Le script appliquera 100%
      - delay: !lambda 'return id(boost_duration).state * 60000;'  # Conversion minutes ‚Üí millisecondes
      - switch.turn_off: boost_mode
    turn_off_action:
      - logger.log: "Fin du Boost"
      - script.execute: update_ventilation

  # --- MODE AUTO LIGNE 1 ---
  # Active la r√©gulation automatique selon la temp√©rature (Ligne 1)
  - platform: template
    name: "Mode Auto Ligne 1"
    id: auto_mode_1
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON  # Activ√© par d√©faut au d√©marrage
    icon: "mdi:thermostat-auto"
    turn_on_action:
      - script.execute: update_ventilation
    turn_off_action:
      - logger.log: "Mode Auto L1 d√©sactiv√©"

  # --- MODE AUTO LIGNE 2 ---
  # Active la r√©gulation automatique selon la temp√©rature (Ligne 2)
  - platform: template
    name: "Mode Auto Ligne 2"
    id: auto_mode_2
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON  # Activ√© par d√©faut au d√©marrage
    icon: "mdi:thermostat-auto"
    turn_on_action:
      - script.execute: update_ventilation
    turn_off_action:
      - logger.log: "Mode Auto L2 d√©sactiv√©"

# =================================================================================================
# LOGIQUE INTELLIGENTE (Scripts)
# =================================================================================================
script:
  # --- SCRIPT PRINCIPAL : Mise √† jour de la ventilation ---
  # Appel√© automatiquement √† chaque changement de temp√©rature ou de r√©glage
  - id: update_ventilation
    mode: restart  # Red√©marre le script si d√©j√† en cours (√©vite les doublons)
    then:
      - logger.log: "===== MAJ VENTILATION ====="
      
      # --- V√âRIFICATION STATE DES CAPTEURS DHT ---
      - lambda: |-
          // Ligne 1
          if (std::isnan(id(temp_1).state)) {
            ESP_LOGW("L1", "‚ö†Ô∏è Capteur DHT d√©faillant");
            id(alert_l1).publish_state(true);
          } else {
            id(alert_l1).publish_state(false);
          }
          
          // Ligne 2
          if (std::isnan(id(temp_2).state)) {
            ESP_LOGW("L2", "‚ö†Ô∏è Capteur DHT d√©faillant");
            id(alert_l2).publish_state(true);
          } else {
            id(alert_l2).publish_state(false);
          }

      # --- CALCUL VITESSE LIGNE 1 ---
      - lambda: |-
          float speed = 0.0;
          
          // PRIORIT√â 1 : Boost Global
          if (id(boost_mode).state) {
            speed = 100.0;
            ESP_LOGI("L1", "üöÄ BOOST : 100%%");
          }
          // PRIORIT√â 2 : Interlock Surchauffe
          else if (id(alert_interlock).state) {
            speed = 100.0;
            ESP_LOGW("L1", "üî• INTERLOCK : 100%%");
          }
          // PRIORIT√â 3 : Fail-Safe (Capteur HS)
          else if (id(alert_l1).state) {
            speed = 50.0;
            ESP_LOGW("L1", "‚ö†Ô∏è FAIL-SAFE : 50%% (capteur d√©faillant)");
          }
          // MODE AUTO (si activ√©)
          else if (id(auto_mode_1).state) {
            float temp = id(temp_1).state;
            float t_min = id(consigne_min).state;
            float t_max = id(consigne_max).state;
            
            // Calcul lin√©aire : 0% √† t_min, 100% √† t_max
            speed = ((temp - t_min) / (t_max - t_min)) * 100.0;
            speed = max(0.0f, min(100.0f, speed));  // Clamp entre 0 et 100
            
            ESP_LOGI("L1", "Auto : %.1f¬∞C ‚Üí %.0f%%", temp, speed);
          }
          // MODE MANUEL (garde l'√©tat actuel)
          else {
            speed = id(fan_1).speed;
            ESP_LOGI("L1", "Manuel : %.0f%%", speed);
          }
          
          // Application avec Kickstart si besoin
          auto call = id(fan_1).make_call();
          if (speed == 0.0) {
            call.set_state(false);  // √âteindre si 0%
          } else {
            call.set_state(true);
            
            // KICKSTART : Impulsion 100% pendant 1 sec pour lancer le ventilateur
            if (speed < 30.0 && !id(fan_1).state) {
              ESP_LOGI("L1", "‚ö° Kickstart (bas r√©gime)...");
              auto kick = id(fan_1).make_call();
              kick.set_state(true);
              kick.set_speed(100);
              kick.perform();
              delay(1000);  // Pause 1 seconde
            }
            
            call.set_speed((int)speed);
          }
          call.perform();

      # --- CALCUL VITESSE LIGNE 2 (Identique √† L1) ---
      - lambda: |-
          float speed = 0.0;
          
          if (id(boost_mode).state) {
            speed = 100.0;
            ESP_LOGI("L2", "üöÄ BOOST : 100%%");
          }
          else if (id(alert_interlock).state) {
            speed = 100.0;
            ESP_LOGW("L2", "üî• INTERLOCK : 100%%");
          }
          else if (id(alert_l2).state) {
            speed = 50.0;
            ESP_LOGW("L2", "‚ö†Ô∏è FAIL-SAFE : 50%% (capteur d√©faillant)");
          }
          else if (id(auto_mode_2).state) {
            float temp = id(temp_2).state;
            float t_min = id(consigne_min).state;
            float t_max = id(consigne_max).state;
            
            speed = ((temp - t_min) / (t_max - t_min)) * 100.0;
            speed = max(0.0f, min(100.0f, speed));
            
            ESP_LOGI("L2", "Auto : %.1f¬∞C ‚Üí %.0f%%", temp, speed);
          }
          else {
            speed = id(fan_2).speed;
            ESP_LOGI("L2", "Manuel : %.0f%%", speed);
          }
          
          auto call = id(fan_2).make_call();
          if (speed == 0.0) {
            call.set_state(false);
          } else {
            call.set_state(true);
            
            if (speed < 30.0 && !id(fan_2).state) {
              ESP_LOGI("L2", "‚ö° Kickstart (bas r√©gime)...");
              auto kick = id(fan_2).make_call();
              kick.set_state(true);
              kick.set_speed(100);
              kick.perform();
              delay(1000);
            }
            
            call.set_speed((int)speed);
          }
          call.perform();

      # --- SURVEILLANCE INTERLOCK (Surchauffe critique) ---
      - lambda: |-
          float t_crit = id(consigne_max).state + 5.0;  // Seuil = Max + 5¬∞C
          bool interlock = false;
          
          if (!std::isnan(id(temp_1).state) && id(temp_1).state >= t_crit) {
            interlock = true;
            ESP_LOGW("INTERLOCK", "‚ö†Ô∏è L1 : %.1f¬∞C >= %.1f¬∞C", id(temp_1).state, t_crit);
          }
          if (!std::isnan(id(temp_2).state) && id(temp_2).state >= t_crit) {
            interlock = true;
            ESP_LOGW("INTERLOCK", "‚ö†Ô∏è L2 : %.1f¬∞C >= %.1f¬∞C", id(temp_2).state, t_crit);
          }
          
          id(alert_interlock).publish_state(interlock);
          
          if (interlock) {
            ESP_LOGE("INTERLOCK", "üî• SURCHAUFFE CRITIQUE : Ventilation forc√©e √† 100%%");
          }

# =================================================================================================
# INTERVALLES DE MISE √Ä JOUR
# =================================================================================================
interval:
  # D√©clenche un recalcul toutes les 30 secondes (s√©curit√©)
  - interval: 30s
    then:
      - script.execute: update_ventilation

# =================================================================================================
# üìù NOTES TECHNIQUES
# =================================================================================================
# 1. **PWM** : Les ventilateurs PWM ne tournent g√©n√©ralement pas en dessous de 5% de puissance
#              (caract√©ristique mat√©rielle normale).
#
# 2. **Kickstart** : Impulsion 100% pendant 1 seconde en dessous de 30% pour garantir le d√©marrage
#                    des moteurs (√©vite les calages √† bas r√©gime).
#
# 3. **Fail-Safe** : Si un capteur DHT22 ne r√©pond plus (NaN), la ligne passe √† 50% par s√©curit√©.
#
# 4. **Interlock** : Si la temp√©rature d√©passe le seuil critique (Max + 5¬∞C), toutes les lignes
#                    passent √† 100% pour √©vacuer la chaleur (priorit√© absolue).
#
# 5. **Priorit√©s** : Boost > Interlock > Fail-Safe > Mode Auto > Mode Manuel
# =================================================================================================
